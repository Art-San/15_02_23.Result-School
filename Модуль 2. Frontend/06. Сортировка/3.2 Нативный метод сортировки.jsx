// Нативные методы

// В примерах выше мы использовали метод из библиотеки lodash. 
// В некоторых проектах использование подобных библиотек может быть запрещено 
// и тебе нужно будет самостоятельно писать методы сортировки. 
// Давай на примере цены рассмотрим, как можно написать собственную сортировку.

// В JS существует метод массива sort(), но в нем есть подвох.

// Разберёмся на примере.

// Представим, что у нас есть массив чисел const arr = [1, 2, 3], 
// и мы хотим задать значения в порядке убывания. Мы вызовем метод sort() для массива. 
// В него нужно передать callback, который принимает два значения (a и b) из этого массива, 
// сравнивает их и возвращает значение:

// 1. меньше 0, если a нужно поставить по меньшему индексу
// 2. больше 0, если a нужно поставить b по меньшему индексу
// 3. 0, если нужно оставить порядок неизменным

const arr = [1, 2, 3];
const result1 = arr.sort((a, b) => b > a ? 1 : -1); // [3, 2, 1]
// или (callback будет возвращать значения больше, меньше или равно 0)
const result2 = arr.sort((a, b) => b - a); // [3, 2, 1]

// Но теперь, если мы сравним arr и result, то увидим, что они равны:

console.log(arr === result1); // true
console.log(arr === result2); // true

// Ссылка на массив не изменилась и это значит, что метод sort() сортирует текущий массив, 
// а не создаёт новый, как, например, методы map() , filter() или slice():

const arr = [3, 2, 1];
const a = arr.sort();
console.log(a === arr); // true

const b = arr.slice();
console.log(b === arr); // false

// Попытка воспользоваться в React-приложении метода без создания нового массива, 
// приведёт к изменению данных, которые мы не планировали менять, 
// непредсказуемому поведению и часам дебага. 

Неверный способ:

{
    value: "priceASC",
    label: "Цена по возрастанию",
    sort: (products) =>
      products.sort((itemA, itemB) => {
        return itemA.price - itemB.price;
      })
  },

//   При попытке воспользоваться этим методом, мы незаметно изменим массив 
//   products - это некорректно. Чтобы этого избежать, 
//   нам нужно каким-то образом вернуть новый массив перед сортировкой. 
//   Например, можно использовать метод массива slice():

products.slice().sort((itemA, itemB) => {
    return itemA.price - itemB.price;
  })

//   Подобное можно реализовать через Spread-syntax:

[...products].sort((itemA, itemB) => {
    return itemA.price - itemB.price;
  })

//   Итоги

// Сортировка – упорядочивание элементов в списке. 
// Для определения порядка используется некоторый метод, по которому происходит сортировка. 
// Для сортировки можно использовать различные библиотеки или нативный метод sort() 
// с передачей callback функции для изменения порядка. 
// При использовании нативного метода нужно помнить о том, что он мутирует (изменяет) текущий

// Полезные ссылки

Lodash orderBy(): https://lodash.com/docs/4.17.15#orderBy

Array.prototype.sort(): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort

Array.prototype.slice(): https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice
