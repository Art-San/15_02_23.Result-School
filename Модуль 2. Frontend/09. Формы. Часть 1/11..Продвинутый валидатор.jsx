// Регулярные выражения

// Сейчас подумаем, какие еще валидаторы 
// мы можем реализовать. К примеру, мы будем проверять: 

// Email – то, что он действительно является Email-ом
// Ссылка – то, что она действительно является ссылкой
// Описание – то, что оно не слишком короткое (к примеру)

// Для проверки мы будем использовать регулярные выражения.

// Регулярные выражения — это шаблоны, 
// используемые для сопоставления 
// последовательностей символов в строках. 
// Если упрощенно, то это мощное средство поиска и замены в строке.

// При желании про них можно подробно почитать здесь.
// https://learn.javascript.ru/regular-expressions

// Разберемся на практике. Мы будем проверять Email на наличие составных частей:
// Для того чтобы работа с регулярными 
// выражениями была наглядной, мы будем использовать сервис
// https://regex101.com/

********************************

// https://regex101.com/

********************************

// В боковой левой колонке у нас выбор среды, 
// в нашем случае ECMAScript (JavaScript) 
// там же ниже функции. Мы воспользуемся:

// Match – для поиска совпадений
// UnitTests – для проверки тех или иных данных на соответствие нашим правилам

// Для начала воспользуемся Match и начнем писать правила. 
// Email не может содержать пробелы, 
// значит нам нужно воспользоваться регулярным 
// выражением поиска всех непробельных символов – \S:

// У нас сейчас есть множество совпадений, 
// так как мы ищем только один непробельный символ. 
// Нам нужно более одного символа. Воспользуемся подсказкой в сервисе. 
// В поиске введём “more”, и сервис нам подсказывает, 
// что нужно выражение “One or more of”. 


// Теперь регулярное выражение будет \S+:

// Продолжим поиск совпадений. Нам нужно найти символ “@”, 
// части домена и точку. В результате получится \S+@\S+\.\S+:

// Символ at (собака) определяется просто как символ @. 

// Точку нужно экранировать обратным слэшем \., 
// чтобы искался именно символ . (так как просто . 
// используется в построении регулярных выражений).

https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#types
  /**
    - `^`        Начните с начала строки
    - `[]`       Разрешить любой указанный символ, включая...
    - `a-z`      что-нибудь от а до я,
    - `0-9`      что-нибудь от 0 до 9,
    - `_`        and underscore.
    - `{4,16}`   Принимать от 4 до 16 разрешенных символов, включая оба числаd.
    - `$`        Завершить строку сразу после того, как будет задано указанное количество разрешенных символов.
  */
// Сейчас наше регулярное выражение может принимать многострочные значения:

// Для того чтобы это исправить, 
// воспользуемся функцией сервиса UnitTests и 
// перечислим в тест-кейсах значения, 
// которые проходят или не проходят по нашим правилам. 


// Первый тест-кейс должен подходить по нашему 
// регулярному выражению, а второй нет. 
// Во втором мы должны выбрать does not match, чтобы он стал зеленым:

// Если у нас указано несколько строк или перед 
// Email есть другое значение, то совпадения быть не должно:

// Сейчас наш тест-кейс проходит неудачно 
// (хотя мы хотим, чтобы он был зеленым). 
// Чтобы исключить из совпадения лишнее, 
// нам нужно воспользоваться так называемыми якорями и указать, 
// что в начале и конце строки не должно быть лишнего:

// Теперь регулярное выражение будет выглядеть так – ^\S+@\S+\.\S+$ (^ – начало строки, $ – конец строки

// Все тест-кейсы станут зелёными:

// Мы получили простейшее регулярное выражение для проверки Email.

// Теперь попробуем создать регулярное выражения для ссылки. 
// Посмотрим, какие у нас могут быть http(s)-ссылки:

// Такая ссылка состоит из:

// 1. Протокол (http или https)
// 2. Двоеточие (:)
// 3. 2 слеша (//)
// 4. Домен (example.com) + опционально поддомены 
// (sub.example.com) + опционально поддиректории 
// (example.com/page) + опционально query-параметры (?id=1)

// Давай создадим простое регулярное выражение 
// для проверки того, что в начале будет http:///https://

// Начнём с написания Unit-тестов:

// Первые два тест-кейса должны быть положительные, 
// а третий НЕ должен проходить, 
// так как у него только один слэш после протокола.

// 1. Напишем определение http и https. 
// У них общая часть http и s опционально. 
// Для опционального символа добавляем ? – https?

// 2. Далее должно идти ://. Добавим в 
// регулярное выражение этот набор символов, экранируя слэши https?:\/\/

// 3. После должна быть остальная часть адреса страницы – https?:\/\/\S+

// 4. И чтобы поле было в одну строку, 
// добавим проверку, что строка началась 
// и закончилась – ^https?:\/\/\S+$

// Как мы видим, все текст-кейсы зеленые:

// Данное регулярное выражение создано в учебных целях, 
// реальное регулярное выражение для проверки 
// URL на порядок сложнее. 
// Ты можешь самостоятельно найти десятки 
// вариантов в интернете. Например, 
// вот такое регулярное выражение в одной 
// из самых популярных библиотек для валидации 
// (затронем её во второй части урока по формам): ссылка. 
// https://github.com/jquense/yup/blob/99aa25787a8ff15fe42e54db88ec3ed547357302/src/string.ts#L25

Валидация в нативном HTML
не дописал спать пошел
https://vladilen.ru/pl/teach/control/lesson/view?id=253065781

// Ранее в уроке мы уже затрагивали валидацию в нативном HTML. 
// Мы использовали атрибут required, но на самом деле, 
// это не единственная возможность. Например, 
// мы можем проверять валидность поля с помощью регулярного выражения. 
// Для этого нам понадобится указать у <input> атрибут pattern, 
// равный регулярному выражению, которому должно соответствовать значение поля. 
// Например, для нашего варианта Email-разметка выглядела бы так:

{/* <form>
    <input 
        type="text"
        pattern="^S+@S+.S+$"
        required
    >
    <button type="submit">Отправить</button>
</form> */}

// Если значение не будет соответствовать регулярному выражению, 
// то при попытке отправить форму мы увидим ошибку:

// Однако такая ошибка не самая информативная 
// (особенно, если ты не показал пользователю в каком формате заполнять). 
// В некоторых случаях атрибут type определяет, 
// какому правилу должно соответствовать поле. 
// Например, для типа email есть свой валидатор:

{/* <form>
    <input 
        type="email"
        required
    >
    <button type="submit">Отправить</button>
</form> */}

// Вот такую ошибку можно увидеть, 
// если введенное значение не будет являться email-ом:

// Ещё пример: если мы захотим проверить минимальное 
// количество символов в значении, то можем воспользоваться атрибутом minlength, 
// который будет указывать минимальное количество символов в строке:

{/* <form>
    <input 
        type="text"
        minlength="6"
        required
    >
    <button type="submit">Отправить</button>
</form> */}

// При желании ты можешь более подробно ознакомиться 
// c атрибутами и типами для <input>: ссылка. 
// https://developer.mozilla.org/en-US/docs/Web/HTML/Element/Input

// Добавление новых валидаторов

// В прошлой части мы создали валидатор. 
// Теперь наполним его новыми правилами и немного отрефакторим.

// Перейдём в validateRules.js и добавим правило для проверки Email:

export const isRequired = (value) => Boolean(value.trim());

export const isEmail = (value) => /^S+@S+.S+$/g.test(value);

// Как ты мог заметить, регулярные выражения в JS можно записывать через слеши 
// // (а если точнее, то между ними). Именно они говорят JavaScript о том, 
// что это регулярное выражение. Под капотом, по сути, 
// создастся обычный объект выражения, у которого будут некоторые методы. 
// В том числе и метод test(), суть которого проверить, 
// есть ли хоть одно совпадение шаблона с переданной строкой. 
// Если есть, то возвращает true, иначе false:

console.log(/^S+@S+.S+$/g.test('asdasdasd')); // false
console.log(/^S+@S+.S+$/g.test('username@host.com')); // true
console.log(/^S+@S+.S+$/g.test('usernamehost.com')); // false

// После последнего слеша / указываются флаги. 
// В данном случае у нас указан флаг g, который означает, 
// что будут искаться все совпадения в строке 
// (без него находится только первое совпадение). 

// Также добавим в функцию validator():

import { isRequired, isEmail } from "./validateRules";

// ...

const validator = (ruleName, value) => {
    switch (ruleName) {
        case "isRequired":
            return isRequired(value);
        case "isEmail":
            return isEmail(value);
        default:
            return true;
    }
};

// Добавим соответствующее правило для нашего поля в validationSchema:

export const validationSchema = {
    email: {
        isRequired: {
            message: "Электронная почта обязательна для заполнения"
        },
        isEmail: {
            message: "Email введён некорректно"
        }
    },
    link: {
        isRequired: {
            message: "Ссылка обязательна для заполнения"
        }
    },
    description: {
        isRequired: {
            message: "Описание обязательно для заполнения"
        }
    }
};

// Также отметим, что если пользуемся флагом g для регулярного 
// выражения в комбинации с методом test(), 
// то не следует выносить регулярное выражение в отдельную переменную. 
// Таким образом, можно получить неочевидное поведение функции валидации. 
// Дело в том, что в глобальном режиме (когда у регулярного выражения указан флаг g) 
// при вызове метода test(), регулярное выражение будет сохранять 
// состояние и продолжать поиск, начиная с прошлой найденной подстроки. 
// Подробнее по ссылке. 

https://stackoverflow.com/questions/10229144/bug-with-regexp-in-javascript-when-do-global-search

export const isRequired = (value) => Boolean(value.trim());

export const isEmail = (value) => /^\S+@\S+\.\S+$/g.test(value)

export const isUrl = (value) => /^https?:\/\/\S+$/g.test(value)



// ==============================================================================

import { isRequired, isEmail, isUrl } from "./validateRules";

export const validate = (values, config) => {
    const errors = {};

    for (const name in values) {
        const validationRules = config[name];
        for (const rule in validationRules) {
            const { message } = validationRules[rule];

            // Вызываем валидатор
            const hasError = !validator(rule, values[name]);

            if (hasError) {
                errors[name] = message;
                break;
            }
        }
    }

    return errors;
};

const validator = (ruleName, value) => {
    switch (ruleName) {
        case "isRequired":
            return isRequired(value);
        case "isEmail":
            return isEmail(value);
        case "isUrl":
            return isUrl(value);
        default:
            return true;
    }
};


// =====================================================================
export const validationSchema = {
    email: {
        isRequired: {
            message: "Электронная почта обязательна для заполнения"
        },
        isEmail: {
            message: "Email введён некорректно"
        }
    },
    link: {
        isRequired: {
            message: "Ссылка обязательна для заполнения"
        },
        isUrl: {
            message: "URL не корректный"
        }
    },
    description: {
        isRequired: {
            message: "Описание обязательно для заполнения"
        }
    }
};

// ======================================================================

// Теперь наша ссылка тоже проверяется. Как мы уже отмечали ранее, 
// данные регулярные выражения являются учебными и, при желании и необходимости, 
// ты сможешь найти/создать максимально точное регулярное выражение 
// под любую ситуацию.


// И теперь давай добавим проверку поля с описанием. 
// Мы будем проверять, что описание не менее 20 символов. 
// Чтобы метод был универсальным, 
// мы будем передавать минимальную длину текста как аргумент. 
// Начнём с написания правила:

export const isRequired = (value) => Boolean(value.trim());

export const isEmail = (value) => /^\S+@\S+\.\S+$/g.test(value);

export const isUrl = (value) => /^https?:\/\/\S+$/g.test(value);

export const min = (value, length) => value.length >= length

// В этом правиле мы видим, что нам нужно передать параметр length. 
// Дополним нашу схему валидации:

export const validationSchema = {
    email: {
        isRequired: {
            message: "Электронная почта обязательна для заполнения"
        },
        isEmail: {
            message: "Email введён некорректно"
        }
    },
    link: {
        isRequired: {
            message: "Ссылка обязательна для заполнения"
        },
        isUrl: {
            message: "Адрес не корректный"
        }
    },
    description: {
        isRequired: {
            message: "Описание обязательно для заполнения"
        },
        min: {
          message: "Описание должно содердать минимум 20 символов",
          param: 20
        }
    }
}

// Как мы видим, в нашей схеме появился параметр param, 
// который мы должны передать для проверки:


import { isRequired, isEmail, isUrl, min } from "./validateRules";

export const validate = (values, config) => {
    const errors = {};

    for (const name in values) {
        const validationRules = config[name];
        for (const rule in validationRules) {
            const { message, param } = validationRules[rule];

            // Вызываем валидатор
            const hasError = !validator(rule, values[name], param);

            if (hasError) {
                errors[name] = message;
                break;
            }
        }
    }

    return errors;
};

const validator = (ruleName, value, param) => {
    switch (ruleName) {
        case "isRequired":
            return isRequired(value);
        case "isEmail":
            return isEmail(value);
        case "isUrl":
            return isUrl(value);
        case "min":
            return min(value, param);
        default:
            return true;
    }
};

// Вот так просто мы добавили параметр для валидации:

// Рефакторинг

// Прежде чем мы пойдём дальше, немного отрефакторим код. 
// Глядя на validator(), видно, что он лишь вызывает определённую функцию по имени, 
// если у нас такая есть. Если такой функции нет, то он возвращает true. 
// Мы можем убрать функцию validator() и внести небольшие изменения:

// validateRules.js
// Экспортируем объект, а не отдельные функции
export default {
    isRequired: (value) => Boolean(value.trim()),
    isEmail: (value) => /^\S+@\S+\.\S+$/g.test(value),
    isUrl: (value) => /^https?:\/\/\S+$/g.test(value),
    min: (value, length) => value.length >= length,
    // Содержит заглавную букву
    isCapitalSymbol: (value) => /[A-Z]+/g.test(value),
    // Содержит число
    isContainDigit: (value) => /\d+/g.test(value)
};

// =============================================================

import validateRules from "./validateRules"

export const validate = (values, config) => {
    const errors = {}

    for (const name in values) {
        const validationRules = config[name]
        for (const rule in validationRules) {
            const { message, param } = validationRules[rule]

            // Получение нужного валидатора
            const validator = validateRules[rule]
            // Вызываем валидатор, если он есть
            const hasError = validator && !validator(values[name], param)

            if (hasError) {
                errors[name] = message
                break
            }
        }
    }

    return errors
}
// Так мы убрали лишний слой логики и можем двигаться дальше.

