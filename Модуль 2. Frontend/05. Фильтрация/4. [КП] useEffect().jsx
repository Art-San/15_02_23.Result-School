// Хук useEffect() помогает отслеживать рендеры нашего приложения. 
// В момент рендера он вызовет переданный ему callback. useEffect() может срабатывать при:

// каждом ререндере компонента
// первом рендере
// изменении какой-то зависимости
// демонтаже компонента

useEffect(()=>{
    // При каждом ререндере
})

useEffect(()=>{
    // При первом рендере
}, [])

useEffect(()=>{
    // При изменении зависимостей someProps1, someProps1
}, [someProps1, someProps1])

useEffect(()=>{
    return () => {
        // вызовется при демонтаже компонента 
    }
})

// В useEffect() передаётся 2 параметра:
// 1. callback, который будет срабатывать, когда useEffect() сработает
// 2. опциональный параметр – массив зависимостей, в котором будут перечислены переменные, 
// при изменении которых useEffect() должен сработать.

// Если мы хотим отловить демонтаж компонента (удаление компонента), 
// то нужно вернуть из него функцию, которая выполнит то, что мы хотим. 

// Иногда мы можем услышать фразу “жизненный цикл”. 
// В прошлых версиях React активно использовалось это понятие, 
// и в классовых компонентах есть методы, которые вызываются в соответствии 
// со стадией жизненного цикла. Можно подробнее прочитать про них самостоятельно (ссылка), 
// это даст тебе больше понимания о работе React. 

// Нам нужно при первом рендере запросить данные об эпизодах и годах. 
// Также при изменении фильтра по году запросить обновленный список эпизодов:

// ...

const EpisodesList = () => {
    const [episodes, setEpisodes] = useState([]);
    const [years, setYears] = useState([]);
    const [filter, setFilter] = useState();

    // ...
    
    // Функция для получения эпизодов
    const getEpisodes = (year) => {
        // Вернет все эпизоды, фильтрация пока не работает
        fetchAll(year).then((response) => setEpisodes(response));
    };

    // Запрашиваем список эпизодов когда меняется фильтр
    useEffect(() => {
        getEpisodes(filter);
    }, [filter]);

    useEffect(() => {
        fetchYears().then((response) => setYears(response));
    }, []);

    // Функция для установки фильтра
    const handleFilterChange = (filter) => {
        setFilter(filter);
    };

    return (
        // ...
    );
};

export default EpisodesList;

// Также в GroupList нужно передать фильтр, список годов и функцию для изменения фильтра:

// В episodesList
<GroupList
    items={years}
    filter={filter}
    onChangeFilter={handleFilterChange}
/>

// Но пока есть недочёт. Если мы воспользовались пагинацией и потом отфильтровали эпизоды, 
// то может возникнуть ситуация, когда фактически элементы есть, но мы их не видим на странице. 
// Для того чтобы избежать этого, при изменении фильтра будем переходить на первую страницу.

// В EpisodesList
const getEpisodes = (year) => {
    // Вернет все эпизоды, фильтрация пока не работает
    fetchAll(year).then((response) => setEpisodes(response));
    setCurrentPage(1); // Устанавливаем страницу
};