// Для того чтобы понять, что такое нормализация и денормализация, 
// нужно ввести несколько понятий.

// Избыточность данных — это условие, создаваемое в базе данных 
// или технологии хранения данных, при котором один и тот же 
// фрагмент данных хранится в двух и более местах. 
// Это может означать два разных поля в одной базе данных 
// или два разных места в нескольких программных средах или платформах. 
// Всякий раз, когда данные повторяются, это представляет собой избыточность данных. 

// Например мы можем хранить подобный массив в нашей программе:

const orders = [
    {
      id: 1,
      date: "10.04.2022",
      products: [
        {
          id: 1,
          price: 200,
          currency: "RUB",
          name: "Коробка с сюрпризом"
        }
      ]
    },
    {
      id: 2,
      date: "11.04.2022",
      products: [
        {
          id: 1,
          price: 200,
          currency: "RUB",
          name: "Коробка с сюрпризом"
        }
      ]
    }
  ];

//   В данном массиве находится список заказов и внутри есть товары. 
//   В обоих заказах есть один и тот же товар, но он повторяется в двух местах. 
//   Такой подход можно назвать избыточным 
//   (в контексте JS за место одной ссылки на объект с товаром, 
//     мы храним два разных объекта). 

// Следующие понятие — согласованность данных. 
// Согласованность данных означает, совпадают ли одни и те же данные, 
// хранящиеся в разных местах.

// В нашем случае, если бы мы захотели, например, изменить цену, 
// нам нужно было бы следить за тем, чтобы цена изменилась в обоих местах. 
// Например, наш пользователь — менеджер сайта, 
// и он хочет дать скидку клиенту на его неоплаченные заказы. 
// Если бы он делал это и цена менялась во всех заказах, 
// то это бы и означало согласованность данных. 

// Теперь мы разберёмся, какие есть методы проектирования баз данных, 
// а именно узнаем, что такое нормализация и денормализация. 
// Начнём с денормализации, так как она чаще встречается 
// во фронтенде в качестве структуры данных при ответах с сервера по API.

// Денормализация

// Денормализация — это метод, который используется при проектировании в базе данных. 
// Он используется для добавления избыточности для быстрого выполнения запроса. 
// Этот метод, при котором данные объединяются. Он обладает характеристиками:

// зеленый Высокая скорость обработки зеленый
// зеленый Малое количество сущностей зеленый
// красный Высокая избыточность данных красный
// красный Несогласованность данных красный

// Пример (order entity):

{
    "id": "2778b73c-228a-4f4f-8e3e-97e775ab45c3",
    "shipment": {
      "type": {
        "id": "50d18e44-a9bf-4a1d-9fba-fa8c73f25dcc",
        "company": "CDEK"
      },
      "details": {
        "price": 200.0,
        "currency": "RUB",
        "adress": {
          "id": "a06b07e0-ccc1-45a3-917c-26591acba433",
          "steet": "ул. Мотросов",
          "city": "г. Неназванный",
          "apartament": "1"
        }
      }
    }
  }

//   У нас есть заказ, у которого есть способ доставки, 
//   адрес доставки и прочие данные. Обычно служба доставки и адрес — это данные, 
//   которые являются справочными и редко меняются.
//    Но если мы хотим отобразить конкретный оформленный 
//    заказ конкретному пользователю, то ему нужна только информация 
//    о его заказе и не нужны все существующие варианты адресов и доставок. 
//    Поэтому мы будем запрашивать из хранилища данных только адрес 
//    в этом заказе, т. е. денормализованные данные. В данном случае денормализация 
//    совершенно оправдана. 


// Но что, если бы мы работали от лица, например, 
// аналитика в интернет-магазине, и мы бы хотели получить список заказов, 
// у которых одна и та же служба доставки? Нам совершенно 
// не нужно было бы хранить множество раз одну и ту же доставку в сущности заказа. 
// Для решения такой задача к нам приходит второй метод проектирования 
// структуры данных — нормализация. 

// Нормализация

// Нормализация — это метод, используемый в базе данных 
// для уменьшения избыточности и несогласованности данных. 
// Это метод, при котором данные без избыточности 
// и непротиворечивости хранятся в установленной схеме.

// Этот метод обладает характеристиками:

// красный Низкая скорость обработки красный
// красный Большое количество сущностей красный
// зеленый Низкая избыточность данных или её отсутствие зеленый
// зеленый Высокая согласованность данных зеленый

// Ниже представлен пример:

{
    "dictionaries": {
      "shipments": [
        {
          "id": "50d18e44-a9bf-4a1d-9fba-fa8c73f25dcc",
          "company": "CDEK"
        },
        {
          "id": "9dac7961-fd65-43d6-9873-715338de09d5",
          "company": "PonyExpress"
        },
        {
          "id": "05ff6f98-feae-41d6-b57e-5788e1e09aab",
          "company": "DPD"
        }
      ]
    },
    "orders": [
      {
        "id": "d7eea0e2-ab44-4839-8dab-cffc9ecdf599",
        "price": 245.5,
        "shipmentTypeId": "50d18e44-a9bf-4a1d-9fba-fa8c73f25dcc"
      },
      {
        "id": "15d15297-06f7-4729-a015-174eb6e56603",
        "price": 2798.9,
        "shipmentTypeId": "50d18e44-a9bf-4a1d-9fba-fa8c73f25dcc"
      }
    ]
  }

//   Мы видим, что у нас заказы и службы доставки разделились 
//   на разные сущности: заказ и доставка. 

// Сущность “заказ” имеет указатель в виде shipmentTypeId на службу доставки. 
// Если бы такой запрос обрабатывался на сервере, то сначала были бы запрошены заказы, 
// собраны идентификаторы служб доставок, и был бы выполнен ещё один запрос за службами доставки.

// Для наглядности можно представить схематически, 
// как происходили бы обращения к базе данных в случае 
// с денормализацией или нормализацией:

// На этих схемах наглядно видно разницу между нормализацией 
// и денормализацией в контексте обращения к данным в хранилище.

// Спойлер

// Возможно ты знаком с реляционными базами данных (например MySQL). 
// При проектировании таких баз данных используют нормализацию. 
// Однако часто нам нужно быстро получать денормализованные данные. 
// Например у нас есть страница списка товаров (в интернет-магазине), 
// в котором данные запрашиваются из разных таблиц БД, и при этом 
// у нас происходят тысячи запросов. В Backend для решения таких задач 
// используют кэш или другую базу данных, например Redis, просто запомнив 
// для определённого id сущности результат запроса из базы данных. 

// Если наше хранилище данных в React использует нормализацию 
// (как, например, советует Redux), то мы можем подобным способом, 
// как на Backend, проводить денормализацию и “кэшировать” с помощью мемоизации. 
// В React мемоизацию в данном контексте можно назвать кэшированием. 
// Например, у нас существует кабинет менеджера интернет-магазина. 
// У него есть хранилище, в котором есть справочники с доступными скидками:

{
    "discountDictionaries": [
      { "id": 1, "value": "5%", "title": "Скидка 5%" },
      { "id": 2, "value": "10%", "title": "Скидка 10%" },
      { "id": 3, "value": "15%", "title": "Скидка 15%" }
    ]
  }

//   В какой-то момент этот менеджер начинает работать 
//   с заказом какого-то пользователя, у которого есть скидка:

{
    "discountDictionaries": [
      { "id": 1, "value": "5%", "title": "Скидка 5%" },
      { "id": 2, "value": "10%", "title": "Скидка 10%" },
      { "id": 3, "value": "15%", "title": "Скидка 15%" }
    ],
    "order": {
      "id": 1000,
      "discountId": 1,
      ...
    }
  }

//   При отображении в кабинете мы хотим показывать менеджеру скидку 
//   в виде текста, и при этом не хотим каждый раз проходиться 
//   по массиву словаря скидок, чтобы найти нужное значение. 
//   Мы можем мемоизировать данные, которые нам нужны для отображения в кабинете:

const OrderPage = (props) => {
    const { discountDictionaries, order } = props;

    const pageData = useMemo(()=>{
        const { discountId, ...rest } = order;
        const discount = discountDictionaries.find(
            ({ id }) => id === discountId
        );
        return {
            ...rest,
            discountTitle: discount.title
        };
    }, [discountDictionaries, order]);

    return (/* ... */);
}

// В переменной pageData мы получили мемоизированный объект 
// с денормализованными данными о заказе 
// (вместо discountId будет сразу discountTitle):

{
    "id": 1000,
    "discountTitle": "Скидка 5%",
    ...
  }