// Для того чтобы вызвать ререндер компонента в React, 
// нужно воспользоваться изменением состояния. 
// Состояние представляет собой внутреннюю переменную компонента, 
// которую можно обновлять по определенному механизму.

// В функциональных компонентах такой механизм реализует хук useState().

// useState() возвращает кортеж (массив), в котором содержится значение 
// состояния и функция для его изменения. По соглашению название функции 
// изменения состояния начинается с "set".

function Component() {
    const [count, setCount] = useState(0);
};

// * Кортеж (в нашем случае) – массив, где элементы расположены в четкой последовательности. 
// В массиве, возвращаемом функцией useState(), порядок элементов всегда 
// одинаковый: первый – значение состояния, второй – функция изменения состояния.

// Хук useState() может принимать первоначальное состояние (или функцию, которая его вычислит). 
// Если первоначальное состояние не будет указано, то оно будет равно undefined.

const [example, setExample] = useState() // [undefined, function]
const [example1, setExample1] = useState(0) // [0, function]

// Чтобы изменить состояние, нам нужно воспользоваться соответствующей функцией.

// Импортируем из react
import React, { useState } from "react";

const Navbar = () => {
  const [open, setOpen] = useState(false);

  const handleMenuClick = () => {
    setOpen(!open);
  };

  return (
    <div>
      <button
        className="btn btn-sm btm-primary"
        onClick={handleMenuClick}
      >
        меню
      </button>
      {open && <div>useState()</div>}
    </div>
  );
};

// О хуке useState() нужно знать несколько вещей.

// Нужно понимать, что хук useState() хранит состояние за пределами нашего компонента. 
// Таким образом, при изменении компонента состояние не приходит к первоначальному виду.


// Ещё хук useState() асинхронный, т.е. он не выполняется в тот же момент, когда мы его вызвали. 
// Это связано с его системой оптимизации. Она реализована так, что ядро React накапливает 
// некоторое число событий по обновлению состояния, такое (число обновлений), 
// чтобы не навредить отображению и не делать слишком частые ререндеры. 
// Поэтому, если система увидит несколько одинаковых событий, то они схлопнутся в одно.

const handleMenuClick = () => {
    setOpen(!open);
    setOpen(!open);
  };


//   Однако, если мы осознанно вызываем изменение состояния дважды, то мы должны указать callback.


// Будет вызвано дважды
const handleMenuClick1 = () => {
    const handleMenuClick = () => {
      // Callback который вернёт новое состояние
      setOpen((prevState) => !prevState);
  
      /*
      * Переменная prevState содержит уже обновленное состояние.
      * Так мы гарантированно работаем с измененным состоянием
      */
      setOpen((prevState) => !prevState); 
  
      /*
      * В нашем случае после двух вызовов setOpen, 
      * переменная open вернется в исходное состояние
      */
    };
  }

//   Уберём второй вызов setOpen((prevState) => !prevState);

// Последнее, что нужно знать о хуке useState() - его содержание может быть любым. 
// Строки, числа, массивы, объекты, массивы объектов и т.д. (кроме функций. Переданная функция в useState() 
// будет вычислена при первом рендере и её результат будет записан в начальное состояние).