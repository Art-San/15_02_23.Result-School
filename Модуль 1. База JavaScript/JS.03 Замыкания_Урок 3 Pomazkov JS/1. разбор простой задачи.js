
function makeCounter(count) {

    return function () {
        return count++    // двойной плюс после переменной (count++ )сперва возвращаем переменую, а потом увеличивает на один
    }                     // двойной плюс перед переменной (++count)  сперва увеличиваем, а затем возвращаем      
}

let counter1 = makeCounter(0)
let counter2 = makeCounter(0)

console.log(counter1()) // 0
console.log(counter1()) // 1

console.log(counter2()) // 0
console.log(counter2()) // 1

// читаемм сверху вниз
первым делом создается 
1. глобальное (лекс, окруж)
ссылка: -> null
переменные: {
    makeCounter: function
}

// на 9 строке происходит первый вызов let counter1 = makeCounter(0) в качестве аргумента передаем 0
мы поподаем в нуторь функци makeCounter на этой стадии создается
новое лекси. окруж. "makeCounter №1"
2. makeCounter №1 
ссылка: -> глобальное л.о
переменные: {
    count: 0     // Хотя мы и не создаем count, он создается автоматом (скрыта)
}
и зовершаем выполнение makeCounter(0),
а результат выполнения функции сохраняем в глобальном (лекс, окруж)
в переменной counter1 (результатом является безымянная функция)

3. глобальное (лекс, окруж)
ссылка: -> null
переменные: {
    makeCounter: function,
    counter1: Function,
}

// Теперь на 10й строке происходит вызов let counter2 = makeCounter(0)
Создатся обсолютно новое лексическое окружение "makeCounter №2"
4. makeCounter №2
ссылка: -> глобальное л.о
переменные: {
    count: 0     // Хотя мы и не создаем count, он создается автоматом (скрыта)
}
// и происходит сохранение результата выполнения функции (makeCounter) в пееменную counter2 в глобальном (лекс, окруж)
5. глобальное (лекс, окруж)
ссылка: -> null
переменные: {
    makeCounter: function,
    counter1: Function,
    counter2: Function
}

Дальше на 13 строке происходит вызов функци counter1().
мы попадаем в внуторь фукции которую вернули до этого, то есть на строку "5"
Для этого вызова функции также создается лексическое окружение

6. counter1
ссылка: -> на makeCounter №1
переменные: {
    нет ни оной переменной // (чтобы выполнить 5ю строку мы пытаемся найти переменную "count" в текущем лекс.окр, и не можем итогда идем по ссылке выше)    
}

7. makeCounter №1 
ссылка: -> глобальное л.о
переменные: {
    count: 0  // когда нашли то возвращаем 0 и прибаляем 1
}

7.1 makeCounter №1 
ссылка: -> глобальное л.о
переменные: {
    count: 1
}

первый console.log(counter1()) // 0

на 13ой строке происходит теже процесы что и на 12ой
только уже в лексическом окружение перемкнная "count = 1"
makeCounter №1 
ссылка: -> глобальное л.о
переменные: {
    // count: 1 мы возвращаем единицу и прибавляем 1
    count: 2
}

Это и есть свойство замыкания - выводить актуальную информации на момент вызова

Дальше поподаем на строку 15 и происходит подобно тому что на  12ой
только обращаемся к другому родительскому-лексическому окружению "makeCounter №2"
А на строке 16 повторение 13ой с обращением к своему родительскому-лексическому окружению "makeCounter №2"