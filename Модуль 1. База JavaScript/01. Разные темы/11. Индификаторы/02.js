// Все идентификаторы являются ссылками
// кроме некоторых случаев когда V8 сюда может вставить число 3 bb: 3
// ***************************************************************************************************
// HOST
// Agent (RunTime)
// Enviroment Record
// {
//   // bb: 0x000031
//   // bb: 0x0011
//   bb: 0x000031
//   cc: 0x000031
//   dd: 0x000031
// }

// программа
// 1. 1 + 3
// 2. let bb = "lorem ipsum"
// 3. bb = 3
// 4. bb = "lorem ipsum"
// 5. var cc = "lorem ipsum"
// 6. let dd = bb

// HEAP
// 0x0001: {
//   type: number
//   val: 1
// }

// 0x0011: {
//   type: number
//   val: 3
// }

// 0x0021: {
//   type: number
//   val: 4
// }

// 0x000031: {
//   type: string
//   val: "lorem ipsum"
// }

// 1.  При выполнении программы строчка за строчкой после вычисления
// в HEAP  будут появляться элементы с результатом вычисления и присвоенным
// уникальным адресом.
//  Строка 1  1 + 3
//    а.  Единица это команда,  которая  вернет  цифру 1
//           и будет записана под номером 0x0001.
//    б.  Тройка команда, и возвращает цифру три со своим
//          номером 0x0011.
//    в.  Теперь когда есть две цифры 1 и 3 будет происходить
//        сложение  и результат 4 тоже запишется по своим номером 0x0021
//    г.  И так со всеми результатами, вычислен и подписан и лежит себе в куче.

// 2.  Команды 1 или 3  возвращают соответственно цифре эта процедура называется
//       вычисление. Сложение этих цифр это тоже вычисление.
//       И даже когда будет "string" ее тоже будут вычислять.

// 3. Теперь наши идентификаторы (переменные)  к примеру с именем bb в строке 2
//       будет связана со значение  "lorem ipsum" через номер (ссылку) 0x000031.
//       Но когда выполнение программа  перейдет на строку 3 то у bb связь поменяется.
//       И будет bb уже связано с другим значением, то есть 3 у которого свой номер 0x0011.

// 4. в HEAP значения будут храниться до тех пор, пока
// garbage collector (сборщик мусора) не решит освободить место

// От GPT
// 1. Выражение 1 + 3 (строка 1):
// * В JavaScript примитивные значения, такие как числа, хранятся непосредственно,
// а не в куче. Число 1 и 3 являются примитивными значениями, и результат
// их сложения (4) тоже является примитивом. Для этих значений
// не требуется хранение в куче, как это делается с объектами или строками.

// * Но если бы это был объект или строка, они действительно
// хранились бы в куче с соответствующими адресами.

// 2. Переменные и их значения:
// * Переменные bb, cc, и dd указывают на один и тот же объект в куче
// (если речь идет о строке "lorem ipsum"). Ваша схема правильно описывает,
// как переменные связываются с данными в памяти через ссылки (указатели).

// * Когда переменной bb присваивается новое значение (например, число 3),
// она начинает указывать на новое значение, и старая ссылка (на "lorem ipsum")
// теряется, если на нее больше не ссылается ни одна переменная.

// 3. HEAP и сборка мусора:
// * Ваше описание о том, как значения хранятся в куче и как сборщик
// мусора освобождает память, верно. Garbage Collector удаляет из памяти
// значения, на которые больше не ссылается ни одна переменная.

// Корректировка вашего представления:

// Enviroment Record
// {
//   // bb: 0x0011 // (сначала 0x000031, потом 0x0011)
//   bb: 0x000031 // после изменения вернется к 0x000031
//   cc: 0x000031
//   dd: 0x000031
// }

// // heap
// 0x000031: {
//   type: string,
//   val: "lorem ipsum"
// }

// Пояснения:
// 1. Строка 1 + 3: Она вычисляется сразу же,
// и поскольку результат — это примитив (4), он не хранится в куче.

// 2. Изменение bb: Когда переменной bb присваивается новое значение (3),
// она теряет ссылку на "lorem ipsum" и начинает ссылаться на число 3.
// В схеме Environment Record эта связь будет обновлена.

// 3. Строка "lorem ipsum": Если другие переменные (например, cc и dd)
// всё ещё ссылаются на строку "lorem ipsum", она останется в памяти.
// Если нет, Garbage Collector удалит её.
