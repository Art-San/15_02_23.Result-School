// https://www.youtube.com/watch?v=vFSvq_ablAM&t=19s
// Асинхронность
// многопоточность
// параллелизм
// опредиление этим терминам в ECMAScript нет, говорит на 2:23 ..

//2:49:50
// В рамках языка js, упрощенная формулировка
// Синхронность - это когда вы получаете результат вычисления какой-то операции сразу после того как эта операция декларирована. (операция, результат вычисления)
// Если у вас результат вычисления какой-либо части из этой операции появляется не тогда когда эта операция декларируется, то тогда вы имеете дело с асинхронным кодом
// Это определение легко  воспринимается на уровне начинающего человека, и она очень не точна для людей которые глубоко работаю с языком JS.

// Доп
// setTimeout(() => {return 7}, 100)
// setTimeout это вызов выражения который сразу возвращает результат (синхроно), а эта функция () => {return 7}  является колбэком.
// это все го лишь навсего строковый набор параметров, проанализированный с точки зрения static semantics, но не сколько еще не связано с JS кодом, которые лежит и ни как не выполняется
// () => {return 7} это код выполняется асинхронно

// Синхронным стейтментом является тот результат работы всех частей его формирования им можно воспользоваться без ограничений в последующим стейтменте, тогда это можно назвать синхронной операцией

// Если давать максимально точное определение с точки зрения языка javaScript, то оно было бы завязано на execution context.
// Синхронным является та операция (задача), у которой ее execution context присутствует в execution context stack одновременно с тем execution context который выступал в момент декларирования этой операции.
// Но это определение понятно тем людям которые глубоко погружены в язык спецификации

// стейтмен может называться синхронным тогда и только тогда когда результат вычисления всех его частей доступен сразу же после его выполнения. Это синхроное выполнение на языке JS.
//А асинхронное совершено противоположное, если какая-то часть из выполня из интерпретируемого стейтмента не предоставляет свой результат сразу после ее декларации, то тогда мы имеем дело с асинхронной функцией

// от GPT-4

// Синхронность и Асинхронность в JavaScript

// Упрощенное Определение:

// Синхронность:
// * Это когда результат выполнения операции доступен сразу после её объявления.
// * Например, когда вы вызываете функцию и сразу получаете результат.
// Пример: let result = 1 + 2; // result будет равен 3

// Асинхронность:
// * Это когда результат выполнения операции доступен не сразу после её объявления.
//  Например, когда результат выполнения функции будет доступен только спустя некоторое время.
// * Пример: setTimeout(() => { console.log(7); }, 100); // Вывод 7 произойдет через 100 миллисекунд

// Подробное Определение:
// Для более глубокого понимания синхронности и асинхронности
// в контексте JavaScript нужно рассмотреть работу execution context
// и execution context stack.

// Синхронные операции:
// * Синхронной является та операция, у которой её execution context (контекст выполнения)
// присутствует в execution context stack (стеке контекстов выполнения) одновременно
// с тем execution context, который был активен в момент объявления этой операции.

// Пример
function syncFunction() {
  console.log('Start')
  let result = 1 + 2
  console.log('Result:', result) // Эта строка выполнится сразу после предыдущей
}
syncFunction() // Вывод: Start, Result: 3

// Асинхронные операции:
// Асинхронной является та операция, у которой её execution context создаётся
// и добавляется в execution context stack позже,
// в отдельный момент времени после её объявления.

// Пример
function asyncFunction() {
  console.log('Start')
  setTimeout(() => {
    console.log('Async Result') // Эта строка выполнится позже, через 100 миллисекунд
  }, 100)
  console.log('End')
}
asyncFunction() // Вывод: Start, End, (через 100 миллисекунд) Async Result

// Как это работает:
// * Event Loop (Цикл событий): Основная часть JavaScript среды,
// которая управляет асинхронными операциями. Event Loop контролирует
// очередь событий и execution context stack.

// * Когда асинхронная операция, такая как setTimeout, завершается,
// её callback (обратный вызов) добавляется в очередь событий (event queue).

// * Event Loop проверяет, пуст ли execution context stack, и если он пуст,
// берет первый callback из очереди событий и помещает
// его в execution context stack для выполнения.

// Таким образом, синхронные операции выполняются последовательно,
// а асинхронные операции откладываются до тех пор,
// пока текущий стек выполнения не освободится.

// Синхронные операции выполняются сразу, а асинхронные откладываются до тех пор,
// пока текущие операции не завершатся, благодаря механизму event loop.
