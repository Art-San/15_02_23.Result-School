// https://www.youtube.com/watch?v=zDlg64fsQow

// Event Loop (событийный цикл)

//    Call Stack
//         ^
// *       |      *
// *       |      *
// *  f-sum(1, 3) *
// *              *
// *  s-sum(2, 2) *   Порядок выполнения попадают в стек и сразу из нег выходят
// *              *
// *  t-sum(3, 3) *
// ****************

// function sum(a, b) {
// return a + b
// }
// const first = sum(1, 1)
// const second = sum(2, 2)
// const third = sum(3, 3)

// ===================================================================

//    Call Stack
//         ^
// *       |      *
// *       |      *
// *    first()   *
// *              *
// *   second()   *
// *              *
// *    third()   *
// ****************

function first() {
  // ...
}
function second() {
  first()
}
function third() {
  second()
}

third()

// Покидание Call Stack:
// first() покидает Call Stack, так как была последней вызванной функцией.
// Затем second() покидает Call Stack, так как её работа была завершена после first().
// И наконец, third() покидает Call Stack, так как она была первой функцией, вызвавшей остальные.

// Этот процесс демонстрирует работу стека вызовов (Call Stack)
// в соответствии с принципом LIFO (Last In, First Out) — последний вошел, первый вышел.

// =====================================================

//    Call Stack
//         ^
// *       |       *
// *       |       *
// *  factorial(1) *
// *  factorial(2) *
// *  factorial(3) *
// *  factorial(4) *
// *  factorial(5) *
// *****************

function factorial(n) {
  if (n < 2) {
    return 1
  }

  return n * factorial(n - 1)
}

factorial(5)

//ERROR приведет к переполнению стека вызовов
// Стандартная глубина стека в
// большинстве современных браузеров составляет около 10000 вызовов.
// function factorial(n) {
//   if (n < 2) {
//     return 1
//   }

//   return n * factorial(n - 1)
// }

// factorial(100000000000)

// Использование цикла for позволяет избежать переполнения стека вызовов,
// поскольку нет необходимости в рекурсивных вызовах функции.
// function factorial(n) {
//   let result = 1
//   for (let i = n; i > 1; i--) {
//     result *= i
//   }

//   return result
// }

// factorial(100000000)

// =====================================================
//
//        Call Stack           1. log('start') зашла и вышла
//            ^                2. setTimeout зашел и вышел, но его колбек попадает в очередь задач
// *          |           *    3. log('end') зашел и вышел,
// *          |           *    4. последней выполняется стрелочная функция () => {}  в которой log('timeout')
// *                      *
// *                      *    Task очередь задач
// *          |           *    **************************************************
// *          |           *    *  () => {log('timeout')}                          *
// *                      *    *                                                *
// *          |           *    *                                                *
// *          |           *    *                                                *
// *                      *    *                                                *
// ************************    **************************************************
// Порядок
// 1. Start
// 2. End
// 3. TimeOut

// 1. Вызов log('start'): Первый вызов функции log с аргументом 'start'.
// Эта функция немедленно выводит значение в консоль и завершает свое выполнение.

// 2. Вызов setTimeout: Затем вызывается функция setTimeout, которая устанавливает
// таймер на 3000 миллисекунд. Внутри колбэка setTimeout вызывается функция
// log с аргументом 'timeout'. Однако, сама функция setTimeout немедленно завершает
// свое выполнение после установки таймера, поэтому она покидает Call Stack сразу же.

// 3. Вызов log('end'): После завершения setTimeout, вызывается функция log
// с аргументом 'end'. Эта функция немедленно выводит значение в консоль
// и завершает свое выполнение.

// Схема показывает, что функция log('start') покидает Call Stack первая,
// за ней следует setTimeout (который немедленно завершает выполнение),
// а затем log('end'). Колбэк setTimeout, который вызывает log('timeout'),
// будет выполнен асинхронно после 3000 миллисекунд, но на момент
// основного потока выполнения кода, он уже покинул Call Stack

function log(value) {
  console.log(value)
}

log('start')

setTimeout(() => {
  log('timeout')
}, 3000)

log('end')
